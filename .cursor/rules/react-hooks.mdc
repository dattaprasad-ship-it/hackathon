---
globs: *.ts,*.tsx
description: Rules and conventions for React hooks usage.
---

# React Hooks Conventions

This guide defines best practices for using React hooks in the frontend application.

## Custom Hook Naming

### Hook File and Function Names

- Custom hooks must start with `use` prefix
- Use **camelCase** for hook names
- Hook files should be named `use{Feature}.ts` or `use{Feature}.tsx`
- Place feature-specific hooks in `features/{feature}/hooks/`
- Place shared hooks in `src/hooks/`

```typescript
// ✅ Good
// hooks/useUser.ts
export const useUser = (userId: string) => {
  // ...
};

// hooks/useProducts.ts
export const useProducts = (filters: ProductFilters) => {
  // ...
};

// ❌ Bad
// hooks/getUser.ts (missing "use" prefix)
// hooks/UserHook.ts (wrong naming convention)
```

## Standard React Hooks

### useState

- Use descriptive names for state variables
- Prefer object state for related values
- Initialize with appropriate default values

```typescript
// ✅ Good
const [user, setUser] = useState<User | null>(null);
const [isLoading, setIsLoading] = useState(false);
const [formData, setFormData] = useState<FormData>({
  name: '',
  email: '',
});

// ❌ Bad
const [data, setData] = useState(null); // Too generic
const [flag, setFlag] = useState(false); // Unclear purpose
```

### useEffect

- Always include dependency array
- Clean up subscriptions and timers
- Extract complex logic into custom hooks

```typescript
// ✅ Good
useEffect(() => {
  const subscription = subscribeToUpdates(userId);
  return () => {
    subscription.unsubscribe();
  };
}, [userId]);

// ❌ Bad
useEffect(() => {
  fetchUser(userId); // Missing dependency array
});

useEffect(() => {
  fetchUser(userId);
}, []); // Missing userId in dependencies
```

### useCallback

- Use for functions passed as props to memoized components
- Include all dependencies in dependency array

```typescript
// ✅ Good
const handleSubmit = useCallback((data: FormData) => {
  onSubmit(data);
}, [onSubmit]);

// ❌ Bad
const handleSubmit = useCallback((data: FormData) => {
  onSubmit(data);
}, []); // Missing onSubmit dependency
```

### useMemo

- Use for expensive computations
- Don't overuse - simple calculations don't need memoization

```typescript
// ✅ Good - Expensive computation
const sortedUsers = useMemo(() => {
  return users.sort((a, b) => {
    // Complex sorting logic
    return a.name.localeCompare(b.name);
  });
}, [users]);

// ❌ Bad - Simple operation doesn't need memoization
const fullName = useMemo(() => {
  return `${firstName} ${lastName}`;
}, [firstName, lastName]); // Just use: const fullName = `${firstName} ${lastName}`;
```

## Custom Hook Patterns

### Data Fetching Hook

```typescript
// ✅ Good - Standard data fetching pattern
export const useUser = (userId: string) => {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    let isCancelled = false;

    const fetchUser = async () => {
      try {
        setIsLoading(true);
        setError(null);
        const data = await userService.getById(userId);
        if (!isCancelled) {
          setUser(data);
        }
      } catch (err) {
        if (!isCancelled) {
          setError(err instanceof Error ? err : new Error('Unknown error'));
        }
      } finally {
        if (!isCancelled) {
          setIsLoading(false);
        }
      }
    };

    fetchUser();

    return () => {
      isCancelled = true;
    };
  }, [userId]);

  return { user, isLoading, error };
};
```

### Form Hook

```typescript
// ✅ Good - Form management hook
export const useForm = <T extends Record<string, any>>(
  initialValues: T,
  onSubmit: (values: T) => Promise<void>
) => {
  const [values, setValues] = useState<T>(initialValues);
  const [errors, setErrors] = useState<Partial<Record<keyof T, string>>>({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleChange = useCallback((name: keyof T, value: any) => {
    setValues((prev) => ({ ...prev, [name]: value }));
    // Clear error when user starts typing
    if (errors[name]) {
      setErrors((prev) => ({ ...prev, [name]: undefined }));
    }
  }, [errors]);

  const handleSubmit = useCallback(async (e: React.FormEvent) => {
    e.preventDefault();
    setIsSubmitting(true);
    try {
      await onSubmit(values);
    } catch (error) {
      // Handle errors
    } finally {
      setIsSubmitting(false);
    }
  }, [values, onSubmit]);

  return {
    values,
    errors,
    isSubmitting,
    handleChange,
    handleSubmit,
  };
};
```

## Hook Rules

1. **Only call hooks at the top level** - Don't call hooks inside loops, conditions, or nested functions
2. **Only call hooks from React functions** - Custom hooks or React components
3. **Return consistent structure** - Custom hooks should return objects with consistent property names
4. **Handle loading and error states** - Data fetching hooks should always return loading and error states

```typescript
// ✅ Good - Top level hook calls
export const UserProfile = ({ userId }: UserProfileProps) => {
  const { user, isLoading, error } = useUser(userId);
  const [isEditing, setIsEditing] = useState(false);

  if (isLoading) return <Spinner />;
  // ...
};

// ❌ Bad - Hook inside condition
export const UserProfile = ({ userId }: UserProfileProps) => {
  if (userId) {
    const { user } = useUser(userId); // Violates rules of hooks
  }
  // ...
};
```
